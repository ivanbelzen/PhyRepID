'''
Protein Repeat Evolution pipeline
August 2018 

Species defined in ensembl_stable_id_species.json
Strings defined in pipeline methods

Fork of normal Snakefile
Denovo repeat detection instead of pfam domain detection.
Run MEME on disjunct set of fasta_ogs/hmm results and OGs  that have pfam repeat trees
'''
import pipeline_methods as pre
import glob

#meme_dataset_file = pre.root+'meme_dataset.json'
meme_dataset_file = pre.root+'meme_todo.json'

#Determine output file list
input_ogs = []
meme_ogs = [] 

with open(meme_dataset_file,'r') as og_ids:
	input_ogs = json.load(og_ids)

meme_ogs = [x[len(pre.fasta_chopped_path):-len('.fa')] for x in glob.glob(pre.fasta_chopped_path+"*.fa")]
print(len(meme_ogs))

meme_ogs_parsed = [x[len(pre.denovo_meme_repeats_path):-len('.fa')] for x in glob.glob(pre.denovo_meme_repeats_path+"*.fa")]
print(len(meme_ogs_parsed))

meme_ogs_filtered = [x[len(pre.denovo_repeats_path):-len('.fa')] for x in glob.glob(pre.denovo_repeats_path+"*.fa")]
print(len(meme_ogs_filtered)) #includes the ones already done but those get skipped bc of progress file

#manually?
#subworkflow chop_sequences:
#	snakefile: "Snakefork_chop"
	
rule all:
	input:
		#expand(pre.progress_path+"{og_id}.chopped_fasta.done", og_id=input_ogs),
		#expand(pre.meme_output_path+"{og_id}/meme.html", og_id=meme_ogs),
		#
		expand(pre.progress_path+"{og_id}.meme_parse_chop.done", og_id=meme_ogs),
		expand(pre.progress_path+"{og_id}.meme_filter_chop.done", og_id=meme_ogs_parsed),
		
		expand(pre.progress_path+"{og_id}.meme_hmm.done", og_id=meme_ogs_filtered),
		expand(pre.denovo_trees_path+"{og_id}.treefile", og_id=meme_ogs_filtered),
		
		expand(pre.genetree_path+"{og_id}.nhx", og_id=meme_ogs_filtered),
		expand(pre.denovo_treefix_path+"{og_id}.treefix.mpr.recon", og_id=meme_ogs_filtered)

		
rule run_meme:
	input:
		pre.fasta_chopped_path+"{og_id}.fa"
	output:
		pre.meme_output_path+"{og_id}/meme.html"
	shell:
		'meme {input} -oc '+pre.meme_output_path+'{wildcards.og_id} -protein -mod anr -minsites 4 -minw 12 -maxw 30 -time 300 -maxiter 10 -nostatus -maxsize 10000000'

rule parse_meme:
	input:
		pre.meme_output_path+"{og_id}/meme.html"
	output:
		pre.progress_path+"{og_id}.meme_parse_chop.done"
	shell:
		'python parse_meme_output.py {input}; touch {output}'

rule select_repeats:
	input: 
		pre.denovo_meme_repeats_path+"{og_id}.fa"
	output:
		pre.progress_path+"{og_id}.meme_filter_chop.done"
	shell:
		'mafft --quiet --localpair --maxiterate 1000 {input} > '+pre.denovo_aligned_path+'{wildcards.og_id}.linsi.fa; \
		hmmbuild --fast --symfrac 0.6 -n \'motif\' '+pre.denovo_hmm_path+'{wildcards.og_id}.hmm '+pre.denovo_aligned_path+'{wildcards.og_id}.linsi.fa; \
		hmmpress -f '+pre.denovo_hmm_path+'{wildcards.og_id}.hmm; \
		hmmscan --domT 0 --domtblout '+pre.denovo_tblout_path+'{wildcards.og_id}.tblout '+pre.denovo_hmm_path+'{wildcards.og_id}.hmm '+pre.fasta_path+'{wildcards.og_id}.fa &>/dev/null; \
		python parse_denovo_tblout_init.py '+pre.denovo_tblout_path+'{wildcards.og_id}.tblout '+pre.fasta_path+'{wildcards.og_id}.fa; \
		touch {output}'  

rule repeat_detection_iteration:
	input:
		pre.denovo_repeats_path+"{og_id}.fa"
	output: 
		pre.progress_path+"{og_id}.meme_hmm.done"
	shell: 
		'bash run_meme_iteration.bash {input}' 	


rule run_iqtree:
	input: 
		pre.denovo_aligned_path+"{og_id}.linsi.fa"
	output:
		pre.denovo_aligned_path+"{og_id}.linsi.fa.treefile", pre.denovo_aligned_path+"{og_id}.linsi.fa.iqtree"
	shell:
		'iqtree-omp -s {input} -bb 1000 -nt AUTO -mset LG,WAG,VT,Dayhoff,JTT -redo'
		
rule mv_iqtree:
	input: 
		pre.denovo_aligned_path+"{og_hit}.linsi.fa.treefile"
	output:
		pre.denovo_trees_path+"{og_hit}.treefile"
	shell:
		'cp {input} {output}'


rule reparse_genetrees:
    input:
        pre.ensembl_path+"{gene_id}.json"
    output:
        pre.fasta_path+"{genetree}_{gene_id}.fa",
        pre.genetree_path+"{genetree}_{gene_id}.nhx"
    shell:
        'python parse_genetree.py {input}'		
				
rule prepare_treefix:
	input:
		treefile = pre.denovo_aligned_path+"{og_id}.linsi.fa.treefile", genetree = pre.genetree_path+"{og_id}.nhx"
	output:
		pre.denovo_aligned_path+"{og_id}.linsi.fa.treefile.rooted", 
		pre.denovo_treefix_path+"{og_id}.stree", pre.denovo_treefix_path+"{og_id}.smap"
	shell:
		'python generate_treefix_input.py {input.treefile} {input.genetree}'

rule run_treefix:
	input: 
		treefile = pre.denovo_aligned_path+"{og_id}.linsi.fa.treefile.rooted", iqtree = pre.denovo_aligned_path+"{og_id}.linsi.fa.iqtree",  smap = pre.denovo_treefix_path+"{og_id}.smap", stree = pre.denovo_treefix_path+"{og_id}.stree"
	output:
		pre.denovo_aligned_path+"{og_id}.treefix.tree"
	shell:
		#| grep -oP "Best-fit model according to BIC: \K.*"
		'model=`cat {input.iqtree} | grep -oP "Best-fit model according to BIC: \K.*"`; treefix -s {input.stree} -S {input.smap} -A .linsi.fa -o .linsi.fa.treefile.rooted -n .treefix.tree -V 0 -m treefix.models.iqtreemodel.CoarseModel -e \'-t AA -m  \'$model\'\' {input.treefile}'

rule mv_treefix:
	input: 
		pre.denovo_aligned_path+"{og_id}.treefix.tree"
	output:
		pre.denovo_treefix_path+"{og_id}.treefix.tree"
	shell:
		'mv {input} {output}'
			
rule run_treefix_annotate:
	input: 
		tree = pre.denovo_treefix_path+"{og_id}.treefix.tree", smap = pre.denovo_treefix_path+"{og_id}.smap", stree = pre.denovo_treefix_path+"{og_id}.stree"
	output:
		pre.denovo_treefix_path+"{og_id}.treefix.mpr.recon"
	shell:
		'tree-annotate -s {input.stree} -S {input.smap} {input.tree}'
